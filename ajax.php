<?php
use Comp\Kacky\DB;
use Comp\Kacky\Game;

session_name('kacicky');
session_cache_limiter('nocache');
session_start();

include('vendor/autoload.php');

function log_message($gid, $uid, $cmd=0, $data=false) {
	if (!is_array($data)) $m_data='';
	else $m_data=base64_encode(serialize($data));
	
	DB::getInstance()->q(
	  "INSERT INTO message
    SET g_id=?, m_cmd=?, m_data=?, m_ts=NOW(), u_id=?",
    ['iisi', $gid, $cmd, $m_data, $uid]
  );
}

function read_messages($gid, $uid, $epoch) {
	$db = DB::getInstance();
  $msg_packet=array();
	
	// first update, epoch is not known
	// skip all messages and announce current epoch as new
	if ($epoch==0) {
		$new_epoch=$db->getval(
		  "SELECT COALESCE(MAX(m_id), 0)
      FROM message
      WHERE g_id=?",
      ['i', $gid]
    );
		$msg_packet[]=array('id'=>$new_epoch*1, 'cmd'=>3);
	} else {
		// get messages for this game (gid), not originating from this player self (uid), newer than epoch
		// do not fetch more than 10 for effectivity reasons
		$res=$db->q(
		  "SELECT m_id, m_cmd, m_data, u_id=? AS self
      FROM message
      WHERE g_id=? AND m_id > ?
      ORDER BY m_id LIMIT 10",
      ['iii', $uid, $gid, $epoch]
    );
		while($row=$res->fetch_row()) {
			// some headers
			$msg=array('id'=>$row[0]*1, 'cmd'=>$row[1]*1, 'self'=>$row[3]*1);
			
			// additional parameters in serialized form
			if (strlen($row[2]))
				$m_data=unserialize(base64_decode($row[2]));
			else
				$m_data=array();
			
			// Merge two arrays with + operator (preserving keys, avoiding key conflicts)
			$msg_packet[]=$msg + $m_data;
		}
	}
	
	return $msg_packet;
}

function refresh($gid, $uid, $epoch) {
	global $abort_packet;
	header('Content-Type: application/json');
	
	$row=DB::getInstance()->getrow(
	  "SELECT g_data, g_active, g_title
    FROM game_kacky
    WHERE g_id=?",
    ['i', $gid]
  );
	if (is_null($row)) {
		echo $abort_packet;
		exit;
	}
	
	$messages = read_messages($gid, $uid, $epoch);
	
	if (count($messages)) {
		if ($row['g_active']) { // in-game stats generated by the class_game
			$g = unserialize(base64_decode($row['g_data']));
			$pid = $g->get_player_id_by_name($_SESSION['uname']);
			// return the new game state to the caller (GUI)
			$gstate = $g->get_state($pid);
		} else { // before-game stats (player and color updates)
			$gstate = before_game_state($row['g_title'], $gid, $uid);
		}
		$gstate['messages'] = $messages;
		echo json_encode($gstate);
	} else echo '[]';
}

function before_game_state($g_title, $gid, $uid) {
	$state=array();
	
	$state['title']=$g_title;
	$state['players'] = array();
	
  $players = DB::getInstance()->getarray(
    "SELECT u_id, u_name, u_color
    FROM user2game
      JOIN `user` USING (u_id)
    WHERE g_id=?",
    ['i', $gid]
  );
	foreach($players as $k=>$p) {
		$state['players'][$k]=array(
			'name'=>$p['u_name'],
			'color'=>$p['u_color'],
			'current'=>($p['u_id']==$uid)
		);
	}
	
	$state['start'] = ((count($players) >= Game::P_MIN) && (count($players) <= Game::P_MAX));
	
	return $state;
}

header('Content-Type: text/plain');

$db = DB::getInstance();

foreach(array('gid'=>0, 'card_id'=>-1, 'param0'=>-1, 'param1'=>-1, 'color'=>-1, 'epoch'=>-1) as $k=>$v) {
  if (isset($_GET[$k])) $$k = $_GET[$k]*1;
  elseif (isset($_POST[$k])) $$k = $_POST[$k]*1;
  else $$k=$v;
}

foreach(array('cmd'=>'nop', 'title'=>'', 'param2'=>'') as $k=>$v) {
  if (isset($_GET[$k])) $$k = $db->escape($_GET[$k]);
  elseif (isset($_POST[$k])) $$k = $db->escape($_POST[$k], true);
  else $$k=$v;
}

if (!isset($_SESSION['login']) || !$_SESSION['login']) exit();

$uid=$_SESSION['uid'];
if (!$uid) exit();

// packet for signalling "stop periodic checking"
// used when there is no reason in querying again
$abort_packet=json_encode(array('messages'=>array(array('id'=>-1, 'cmd'=>2))));
		
switch($cmd) {
	case 'send_text_message':
		if (!$gid) break;
		if (!$game['in_game']) break;
		if (!$game['g_active']) break;
		
		log_message($gid, $uid, 100, array(
			'text'=>'<span class="msg-col'.$game['u_color'].'">'.htmlentities($_SESSION['uname'].': '.$db->mq_remove($title)).'</span>'
		));
		break;
		
	// periodic check for new messages
	case 'r':
		refresh($gid, $uid, $epoch);
		break;
		
  case 'nop':
  default: break;
}
exit();